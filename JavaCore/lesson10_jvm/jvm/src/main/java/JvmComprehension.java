
/*  Сначала выполняет работу:
    1. ClassLoaders
    1.1 Loading(подгрузка) JVM подгружает все классы, которые встречаються в нашей
    программе через систему загрузчиков классов Application/Platform/Bootstrap ClassLoaders
    + может быть свой ClassLoaders
    Классы, которые подгружаються в нашей програме:
        -JvmComprehension
        -Object
        -Integer
        -System
    если JVM не находит класс, то выбрасываеться исключение - ClassNotFoundException.

    1.2 Linking(связывание) - подготовка классов к выполнению
        -Verify(проверка валидности кода)
        -Prepare(подготовка примитивов и статических полей)
        -Resolve(связывание ссылок на другие классы)

    1.3 Initialization(инициализация) - выполняеться инициализация класса
        -static инициализаторы
        -static поля

    2. Runtime Data Area - области памяти
    2.1 Metaspace - именно сюда подгружаеться метаинформация о классах из пункта 1. ClassLoader
       -данные о клаассе(имя, методы, поля)
       -константы
    можно настроить  размер данной области памяти, но как правило за ее размером не нужно следить

    2.2 Stack Memory
    2.3 Heap
*/
public class JvmComprehension {
    public static void main(String[] args) { //во время вызова метода создаеться кадр - "main()" в стеке 2.2
        int i = 1;                      //это локальная переменная, она будет помещена в стек в тело метода - "main()"

        Object o = new Object();        /*в куче - 2.3 выделяеться память под объект типа Object куда и сохраняеться
                                        сам объект, в теле метода - "main() в переменной - "о" сохраняеться ссылка
                                        на ячейку памяти в хипе, где храниться объект  */

        Integer ii = 2;                 /*переменная ii также будет просто сохранена в стеке в теле метода - "main()"
                                        (но тут не полностью уверен, возможно будет работать, как со String )  */

        printAll(o, i, ii);             /*создаеться новый кадр(фрейм) - "printAll()" в стеке -2.2 и в теле данного
                                        метода создаеться создаються поля param, куда передаеться ссылка на объект и
                                        значения переменных i и ii, далее выполняються пункты 5 и 6, описанные ниже

                                        пункт 5.  переменная uselessVar также будет просто сохранена в стеке со своим
                                        значением в теле метода - "printAll()"
                                        (но тут не полностью уверен, возможно будет работать, как со String ) */
        
        System.out.println("finished"); /*в хипе 2.3(в особой области) выделяеться место под строку String, где
                                        будет храниться значение - "finished" и в теле метода -  println() появляеться
                                        поле param, которое хранит ссылку на нашу строку*/
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  /* 6 создается еще один фрейм(кадр) в стеке куда в качестве параметра
                                                    передастся ссылка на объект  и значения переменных i и ii*/
    }
}
